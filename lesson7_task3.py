# 3. Реализовать программу работы с органическими клетками.
# Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число). ??? не количеству ячеек в клетке ???
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()),
# вычитание (__sub__()),
# умножение (__mul__()),
# деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться округление значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
class Cell: # cell == клетка, square == ячейка
    def __init__(self, number_of_squares):  # number_of_squares = число ячеек в клетке
        self.cells_total = 3  # cells_total = количество клеток из Дано. Зачем оно - не поняла. Все операции совершаются над 2мя клетками.
        self.squares = int(number_of_squares)

    def __add__(self, other):
        return self.squares + other.squares

    def __sub__(self, other):
        if (self.squares - other.squares) > 0:
            return self.squares - other.squares
        else:
            return 'ВЫЧИТАНИЕ НЕВОЗМОЖНО\n!Количество ячеек уменьшаемой клетки не превосходит вычитаемого!'

    def __mul__(self, other):
        return self.squares * other.squares

    def __truediv__(self, other):
        return self.squares // other.squares

    def make_order(self, squares_in_row): # squares_in_row = число ячеек в ряду
        print(f'сортировка по числу ({squares_in_row}) ячеек в ряду для {self.cells_total} клеток с {self.squares} ячейками:')
        t = self.cells_total
        n = self.squares
        r = int(squares_in_row)
        result = []
        for i in range ((t * n) // r):
            result.append(f'{("*" * r)}\\n')
        if ((t * n) % r) != 0:
            result.append(str('*' * ((t * n) % r)))
        str_result = ''.join(result)
        return str_result

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

cell1 = Cell(4)
cell2 = Cell(2)
print('количество ячеек в клетке, полученной в результате сложения двух заданных клеток: ', cell1 + cell2)
print('количество ячеек в клетке, полученной в результате вычитания двух клеток в заданном порядке: ', cell1 - cell2)
print('количество ячеек в клетке, полученной в результате умножения двух заданных клеток: ', cell1 * cell2)
print('количество ячеек в клетке, полученной в результате деления двух заданных клеток: ', cell1 / cell2)
cell3 = Cell(cell1 + cell2)
print(cell3.make_order(5))